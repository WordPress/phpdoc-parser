<?php

namespace WPFuncRef;

use WP_CLI;

/**
 * Handles creating and updating posts from (functions|classes|files) generated by phpDoc.
 *
 * Based on the Importer class from https://github.com/rmccue/WP-Parser/
 */
class Importer {

	/**
	 * Taxonony name for files
	 *
	 * @var string
	 */
	public $taxonomy_file;

	/**
	 * Taxonomy name for a function's @since tag
	 *
	 * @var string
	 */
	public $taxonomy_since_version;

	/**
	 * Post type name for functions
	 *
	 * @var string
	 */
	public $post_type_function;

	/**
	 * Post type name for classes
	 *
	 * @var string
	 */
	public $post_type_class;

	public $taxonomy_package;  // todo
	public $post_type_hook;    // todo

	/**
	 * Stores a reference to the current file's term in the file taxonomy
	 *
	 * @var string
	 */
	public $file_term_id;

	/**
	 * @var array Human-readable errors
	 */
	public $errors = array();


	/**
	 * Constructor. Sets up post type/taxonomy names.
	 *
	 * @param array $args Optional. Associative array; class property => value.
	 */
	public function __construct( array $args = array() ) {

		$r = wp_parse_args( $args, array(
			'post_type_class'        => 'wpapi-class',
			'post_type_function'     => 'wpapi-function',
			'taxonomy_file'          => 'wpapi-source-file',
			'taxonomy_since_version' => 'wpapi-since',
		) );

		foreach ( $r as $property_name => $value ) {
			$this->{$property_name} = $value;
		}
	}

	/**
	 * For a specific file, go through and import the file, functions, and classes.
	 *
	 * @param array $file
	 * @param bool $skip_sleep Optional; defaults to false. If true, the sleep() calls are skipped.
	 * @param bool $import_internal_functions Optional; defaults to false. If true, functions marked @internal will be imported.
	 */
	public function import_file( array $file, $skip_sleep = false, $import_internal_functions = false ) {

		// Maybe add this file to the file taxonomy
		$slug = sanitize_title( str_replace( '/', '_', $file['path'] ) );
		$term = get_term_by( 'slug', $slug, $this->taxonomy_file, ARRAY_A );
		if ( ! $term ) {

			$term = wp_insert_term( $file['path'], $this->taxonomy_file, array( 'slug' => $slug ) );
			if ( is_wp_error( $term ) ) {
				$this->errors[] = sprintf( 'Problem creating file tax item "%1$s" for %2$s: %3$s', $slug, $file['path'], $term->get_error_message() );
				return;
			}

			// Grab the full term object
			$term = get_term_by( 'slug', $slug, $this->taxonomy_file, ARRAY_A );
		}

		$this->file_term_id = $term['name'];

		// Functions
		if ( ! empty( $file['functions'] ) ) {
			$i = 0;

			foreach ( $file['functions'] as $function ) {
				$this->import_function( $function, 0, $import_internal_functions );
				$i++;

				// Wait 3 seconds after every 10 items
				if ( ! $skip_sleep && $i % 10 == 0 )
					sleep( 3 );
			}
		}

		// Classes
		if ( ! empty( $file['classes'] ) ) {
			$i = 0;

			foreach ( $file['classes'] as $class ) {
				$this->import_class( $class, $import_internal_functions );
				$i++;

				// Wait 3 seconds after every 10 items
				if ( ! $skip_sleep && $i % 10 == 0 )
					sleep( 3 );
			}
		}
	}

	/**
	 * Remove inline newlines in the $input string.
	 *
	 * This tidies up a block of text from phpDoc where the author split the block over multiple lines.
	 * We remove the inline newlines and replace with a space to avoid getting the end of one line being
	 * joined to the beginning of the next line, without any space inbetween.
	 *
	 * This regex was taken from wpautop().
	 *
	 * @param string $input
	 * @return string
	 */
	public static function _fix_linebreaks( $input ) {
		return preg_replace( '|(?<!<br />)\s*\n|', ' ', $input );
	}

	/**
	 * Create a post for a function
	 *
	 * @param array $data Function
	 * @param int $class_post_id Optional; post ID of the class this method belongs to. Defaults to zero (not a method).
	 * @param bool $import_internal_functions Optional; defaults to false. If true, functions marked @internal will be imported.
	 */
	public function import_function( array $data, $class_post_id = 0, $import_internal_functions = false ) {
		global $wpdb;

		// Don't import functions marked @internal unless explicitly requested. See https://github.com/rmccue/WP-Parser/issues/16
		if ( ! $import_internal_functions && wp_list_filter( $data['doc']['tags'], array( 'name' => 'internal' ) ) ) {

			if ( $class_post_id )
				WP_CLI::line( sprintf( "\tSkipped importing @internal method \"%1\$s\"", $data['name'] ) );
			else
				WP_CLI::line( sprintf( "\tSkipped importing @internal function \"%1\$s\"", $data['name'] ) );

			return;
		}

		$is_new_post = true;
		$slug        = sanitize_title( $data['name'] );
		$post_data   = array(
			'post_content' => self::_fix_linebreaks( $data['doc']['long_description'] ),
			'post_excerpt' => self::_fix_linebreaks( $data['doc']['description'] ),
			'post_name'    => $slug,
			'post_parent'  => (int) $class_post_id,
			'post_status'  => 'publish',
			'post_title'   => $data['name'],
			'post_type'    => $this->post_type_function,
		);

		// Look for an existing post for this function
		$existing_post_id = $wpdb->get_var( $wpdb->prepare( "SELECT ID FROM $wpdb->posts WHERE post_name = %s AND post_type = %s AND post_parent = %d LIMIT 1", $slug, $this->post_type_function, (int) $class_post_id ) );

		// Insert/update the function post
		if ( ! empty( $existing_post_id ) ) {
			$is_new_post     = false;
			$post_data['ID'] = (int) $existing_post_id;
			$ID              = wp_update_post( $post_data, true );

		} else {
			$ID = wp_insert_post( $post_data, true );
		}

		if ( ! $ID || is_wp_error( $ID ) ) {
			$this->errors[] = sprintf( 'Problem inserting/updating post for function "%1$s": %2$s', $data['name'], $ID->get_error_message() );
			return;
		}

		// If the function has @since markup, assign the taxonomy
		$since_version = wp_list_filter( $data['doc']['tags'], array( 'name' => 'since' ) );
		if ( ! empty( $since_version ) ) {

			$since_version = array_shift( $since_version );
			$since_version = $since_version['content'];
			$since_term    = term_exists( $since_version, $this->taxonomy_since_version );

			if ( ! $since_term )
				$since_term = wp_insert_term( $since_version, $this->taxonomy_since_version );

			// Assign the tax item to the post
			if ( ! is_wp_error( $since_term ) )
				wp_set_object_terms( $ID, (int) $since_term['term_id'], $this->taxonomy_since_version );
			else
				WP_CLI::warning( "Cannot set @since term: " . $since_term->get_error_message() );
		}

		// Set other taxonomy and post meta to use in the theme template
		wp_set_object_terms( $ID, $this->file_term_id, $this->taxonomy_file );

		update_post_meta( $ID, '_wpapi_args',     $data['arguments'] );
		update_post_meta( $ID, '_wpapi_line_num', $data['line'] );
		update_post_meta( $ID, '_wpapi_tags',     $data['doc']['tags'] );

		if ( $class_post_id ) {
			update_post_meta( $ID, '_wpapi_final',      (bool) $data['final'] );
			update_post_meta( $ID, '_wpapi_abstract',   (bool) $data['abstract'] );
			update_post_meta( $ID, '_wpapi_static',     (bool) $data['static'] );
			update_post_meta( $ID, '_wpapi_visibility',        $data['visibility'] );
		}

		// Everything worked! Woo hoo!
		if ( $is_new_post ) {
			if ( $class_post_id )
				WP_CLI::line( sprintf( "\tImported method \"%1\$s\"", $data['name'] ) );
			else
				WP_CLI::line( sprintf( "\tImported function \"%1\$s\"", $data['name'] ) );

		} else {
			if ( $class_post_id )
				WP_CLI::line( sprintf( "\tUpdated method \"%1\$s\"", $data['name'] ) );
			else
				WP_CLI::line( sprintf( "\tUpdated function \"%1\$s\"", $data['name'] ) );
		}
	}

	/**
	 * Create a post for a class
	 *
	 * @param array $data Class
	 * @param bool $import_internal_classes Optional; defaults to false. If true, functions marked @internal will be imported.
	 */
	protected function import_class( array $data, $import_internal_classes = false ) {
		global $wpdb;

		// Don't import classes marked @internal unless explicitly requested. See https://github.com/rmccue/WP-Parser/issues/16
		if ( ! $import_internal_classes && wp_list_filter( $data['doc']['tags'], array( 'name' => 'internal' ) ) ) {
			WP_CLI::line( sprintf( "\tSkipped importing @internal class \"%1\$s\"", $data['name'] ) );
			return;
		}

		$is_new_post = true;
		$slug        = sanitize_title( $data['name'] );
		$post_data   = array(
			'post_content' => self::_fix_linebreaks( $data['doc']['long_description'] ),
			'post_excerpt' => self::_fix_linebreaks( $data['doc']['description'] ),
			'post_name'    => $slug,
			'post_status'  => 'publish',
			'post_title'   => $data['name'],
			'post_type'    => $this->post_type_class,
		);

		// Look for an existing post for this class
		$existing_post_id = $wpdb->get_var( $wpdb->prepare( "SELECT ID FROM $wpdb->posts WHERE post_name = %s AND post_type = %s LIMIT 1", $slug, $this->post_type_class ) );

		// Insert/update the function post
		if ( ! empty( $existing_post_id ) ) {
			$is_new_post     = false;
			$post_data['ID'] = (int) $existing_post_id;
			$ID              = wp_update_post( $post_data, true );

		} else {
			$ID = wp_insert_post( $post_data, true );
		}

		if ( ! $ID || is_wp_error( $ID ) ) {
			$this->errors[] = sprintf( 'Problem inserting/updating post for class "%1$s": %2$s', $data['name'], $ID->get_error_message() );
			return;
		}

		// If the function has @since markup, assign the taxonomy
		$since_version = wp_list_filter( $data['doc']['tags'], array( 'name' => 'since' ) );
		if ( ! empty( $since_version ) ) {

			$since_version = array_shift( $since_version );
			$since_version = $since_version['content'];
			$since_term    = term_exists( $since_version, $this->taxonomy_since_version );

			if ( ! $since_term )
				$since_term = wp_insert_term( $since_version, $this->taxonomy_since_version );

			// Assign the tax item to the post
			if ( ! is_wp_error( $since_term ) )
				wp_set_object_terms( $ID, (int) $since_term['term_id'], $this->taxonomy_since_version );
			else
				WP_CLI::warning( "Cannot set @since term: " . $since_term->get_error_message() );
		}

		// Set taxonomy and post meta to use in the theme template
		wp_set_object_terms( $ID, $this->file_term_id, $this->taxonomy_file );

		update_post_meta( $ID, '_wpapi_line_num', $data['line'] );
		update_post_meta( $ID, '_wpapi_tags',     $data['doc']['tags'] );
		update_post_meta( $ID, '_wpapi_final',    (bool) $data['final'] );
		update_post_meta( $ID, '_wpapi_abstract', (bool) $data['abstract'] );

		// Everything worked! Woo hoo!
		if ( $is_new_post )
			WP_CLI::line( sprintf( "\tImported class \"%1\$s\"", $data['name'] ) );
		else
			WP_CLI::line( sprintf( "\tUpdated class \"%1\$s\"", $data['name'] ) );

		// Now add this class' methods
		foreach ( $data['methods'] as $method )
			$this->import_function( $method, $ID );
	}
}